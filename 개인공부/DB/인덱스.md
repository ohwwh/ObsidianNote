DB의 조회 속도를 늘리기 위한 자료구조.

[https://rebro.kr/167](https://rebro.kr/167)

특정 컬럼에 대해서 인덱스를 생성하면, 해당 컬럼을 따로 메모리 상에 저장하게 된다. 이 때 컬럼은 값 + 위치 포인터의 형태로 저장되며, 컬럼을 저장할 떄는 보통 조회에 최적화된 자료구조를 이용한다.

1. 해시 테이블 (Key, Value) = (값, 위치 포인터) 같은 형식이 된다. 특정 자료를 찾을 때 해시충돌이 나지 않는 다면 O(1) 만에 찾을 수 있다. 하지만, 부등호 연산에 대해서는 똑같이 오래 걸린다. 예를 들어, type = 51은 금방 찾을 수 있지만 type ≠ 51 혹은 type > 51 같은 건 해시 테이블 특성상 등호 연산 만큼 빠르게 찾을 수 없다.
2. B+Tree B+Tree란? 항상 자료를 정렬된 상태로 저장하기 때문에, 등호건 부등호건 O(logn) 만에 찾을 수 있다. 하지만 만약 DB에 데이터를 삽입, 삭제, 수정 하는 경우에는 매번 다시 정렬을 해야 하기 때문에 오버헤드가 걸린다는 단점이 있다.
![[Untitled (2).png | 500]]
트리의 노드는 연결리스트이며, 각 연결 리스트의 노드 하나가 하나의 값을 의미한다. 이 노드는 구조체로써 와 같이 헤더, 컬럼키, 인덱스키, 값, ROWID(위치 포인터)로 이루어져 있다.

- 결합 인덱스 복합 인덱스, 다중 컬럼 인덱스라고도 한다. 2개 이상의 컬럼이 걸려 있는 인덱스를 뜻한다. 정렬하여 저장을 할 때, 걸려 있는 컬럼의 순서에 따라 사전 편찬 식 정렬이 이루어진다. 즉, 1차적으로 첫 번째 컬럼을 기준으로 정렬한 후 해당 컬럼 값이 같은 경우들을 모아 두 번째 컬럼을 기준으로 다시 정렬하여 저장하는 방식이다.
- 결합 인덱스의 순서 인덱스의 경우 해당 컬럼에 해당하는 인덱스를 불러와서 서칭을 한다면, 결합 인덱스는 두 가지의 컬럼을 순서대로 검사한다. 따라서 두 컬럼의 순서 관계가 중요하다.
    - 케이스 1 Name과 Sex 컬럼으로 인덱스를 만들고, 성별이 남자고 이름이 Smith인 사람을 뽑아내고 싶다고 하자. 만약 Sex, Name 순서로 만든다면 먼저 Sex = male인 row를 뽑아낸 후 이 중에서 Name = Smith인 row를 뽑아내게 된다. 반대라면 Name = Smith인 사람들 중 Sex = male인 데이터를 추출하게 된다. 얼핏 보아도, 첫번째 단계에서 걸러지는 데이터는 Name, Sex 순으로 인덱스를 만들 때 더 많을 것이다. 이런 식으로, 데이터의 종류를 파악하여 인덱스에 걸리는 컬럼의 순서를 예측하는 것이 검색 속도 향상에 매우 중요하다.
    - 케이스 2 만약 결합 인덱스에 user_no와 type 컬럼이 순서대로 걸려 있다고 하자. 만약 user_no과 type을 조건으로 걸어서 조회를 한다면, 매우 빠를 것이다. 하지만, type만 조건으로 걸려고 한다면 type만 걸린 단일 인덱스보다도 조회 속도가 느릴 것이다. type_no만 놓고 본다면 정렬이 되어 있다고 보기 어렵기 때문이다. user_no만 조건으로 걸었다면 빠르게 찾았을 것이다.